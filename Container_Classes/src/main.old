/********* Include statements *********/

#include <iostream>
#include <map>
#include <set>

#include <unordered_map>
#include <unordered_set>
#include <sstream>

/**************************************/

/********** Define statements *********/

#define MSG_TEST_ASSOCIATIVE_CONTAINERS "Testing associative containers."
#define MSG_TEST_UNORDERED_CONTAINERS   "Testing unordered containers."

/**************************************/

/******** Function definitions ********/

void TestAssociativeContainers(void)
{
    PrintTestHeader(MSG_TEST_ASSOCIATIVE_CONTAINERS);

    // Maps: balanced binary trees under the hood. Keys are immutable. Collection of key-value std::pair elements.
    // Does not allow duplicate keys. Can be defined directly as follows. Basic operations include: insert ([]),
    // count, find, at, size.
    std::map<std::string, unsigned int> name_2_age_map = 
    {
        {"Alice"    , 23},
        {"Bob"      , 25},
        {"Charlie"  , 30},
    };

    auto print_map = [](const std::string& map_name, auto input_map) -> void
    {
        size_t input_map_size = input_map.size();
        size_t idx = 0;

        std::cout << map_name << " = { ";
        
        for(auto it = input_map.begin(); it != input_map.end(); it++)
        {
            std::cout << "{" << it->first << ", " << it->second << "}";

            if(idx++ < (input_map_size - 1))
                std::cout << ", ";
        }

        std::cout << " }" << std::endl;
    };

    print_map("name_2_age_map", name_2_age_map);   

    std::map<int, int> histogram_map;
    std::vector<int> hist_values = {1, 23, 1, 45, 33, 67, 89, 33, 1};

    for(int n : hist_values)        // Values can be added one by one too.
        ++histogram_map[n];
    
    if(histogram_map.count(33))     // You can count how many keys with a given value (although it's always 1 or 0 in single key maps).
        histogram_map.at(33) = 33;  // Maps can also be accessed by using .at() method alongside a valid key. It will return an out of bounds exception if the target key does not exist.

    print_map("histogram_map", histogram_map);

    // Sets: again, a balanced binary tree. It's an ordered container that stores unique elements of a specified type.
    // It's automatically and duplicates are not allowed. Basic operations include: insert, erasem findm count, size.
    std::vector<int> set_values = hist_values;
    std::set<int> set_0;   
 
    for(int n : set_values)
        set_0.insert(n);

    auto print_set = [](const std::string& set_name, auto input_set) -> void
    {
        size_t input_set_size = input_set.size();
        size_t idx = 0;

        std::cout << set_name << " = { ";
        
        for(auto s : input_set)
        {
            std::cout << s;
            
            if(idx++ < (input_set_size - 1))
                std::cout << ", ";
        }

        std::cout << " }" << std::endl;
    };

    print_set("set_0", set_0);

    std::set<std::string> set_1 = {"Ein", "Zwei", "Drei", "Vier"};  // Sets can be defined and declared in a single statements too, same as if they were a mere vector.
    
    set_1.erase("Drei");    // Erase elements by using .erase() method alongside the element to be removed.
    
    if(!set_1.count("Acht"))
        set_1.insert("Acht");

    print_set("set_1", set_1);

    // Multimaps: same as maps, but allowing multiple values for each key. Different from maps, multimaps have no []
    // operator overloading (use .insert() instead). When it comes to retrieval, .at(method) cannot be used either,
    // but three alternatives exist in exchange:
    // ·.equal_range(): returns all matches.
    // ·.find(): returns first occurrence.
    std::multimap<int, std::string> age_2_name_map =
    {
        {30 ,   "Jon"   },
        {29 ,   "Ander" },
        {30,    "Marta" },
        {28,    "Cyrin" },
        {25,    "Leire" },
        {30,    "Juan"  },
        {25,    "Manu"  },
    };

    auto print_multimap = [](const std::string& multimap_name, const auto& input_multimap) -> void
    {
        using MapType   = std::decay_t<decltype(input_multimap)>;
        using KeyType   = typename MapType::key_type;
        using ValueType = typename MapType::mapped_type;

        std::set<KeyType> multimap_keys;
        for (auto it = input_multimap.begin(); it != input_multimap.end(); ++it)
            multimap_keys.insert(it->first);

        std::cout << multimap_name << " = " << std::endl << "{ " << std::endl;

        std::vector<ValueType> key_values;

        for (auto key : multimap_keys)
        {
            auto key_range = input_multimap.equal_range(key);
            key_values.clear();

            for (auto it = key_range.first; it != key_range.second; ++it)
                key_values.emplace_back(it->second);

            std::ostringstream oss;
            oss << key; // requires operator<< for KeyType
            printSequenceContainer(oss.str(), key_values);
        }

        std::cout << " }" << std::endl;
    };

    print_map("age_2_name_map", age_2_name_map);
    print_multimap("grouped_age_2_name_map", age_2_name_map);

    // Multisets: sames as sets, store elements in ascending order. It allows duplicated elements.
    // Allows insert, erase, count, find, lower/upper_bound, equal_range.
    std::multiset<int> m_set_0;
    m_set_0.insert(5);
    m_set_0.insert(1);
    m_set_0.insert(5);
    m_set_0.insert(3);
    m_set_0.insert(2);
    m_set_0.insert(2);

    print_set("m_set_0", m_set_0);
}

void TestUnorderedContainers(void)
{
    PrintTestHeader(MSG_TEST_UNORDERED_CONTAINERS);

    // Unordered sets: same as common sets, but with faster access ( O(1) vs O(log(n)) ).
    // Elements within are not ordered.
    std::unordered_set<int> u_s_0 ={1, 2, 5};
    u_s_0.insert(1);
    u_s_0.insert(7);
    u_s_0.insert(8);
    u_s_0.insert(2);

    auto print_set = [](const std::string& set_name, auto input_set) -> void
    {
        size_t input_set_size = input_set.size();
        size_t idx = 0;

        std::cout << set_name << " = { ";
        
        for(auto s : input_set)
        {
            std::cout << s;
            
            if(idx++ < (input_set_size - 1))
                std::cout << ", ";
        }

        std::cout << " }" << std::endl;
    };
    
    print_set("u_s_0", u_s_0);
    
    // Unordered map: same as common maps, but with faster access ( O(1) vs O(log(n)) ). Standard library provides std::hash for
    // basic types like int, std::tring and so on. For other types (such as std::pair) there's no built-in hash
    // function, so a custom one has to be defined in such cases.
    std::unordered_map<int, std::string> u_map_0 =
    {
        {1  ,   "Uno"   },
        {4  ,   "Quatre"},
        {3  ,   "Hiru"  },
        {2  ,   "Zwei"  },
    };

    auto print_map = [](const std::string& map_name, auto input_map) -> void
    {
        size_t input_map_size = input_map.size();
        size_t idx = 0;

        std::cout << map_name << " = { ";
        
        for(auto it = input_map.begin(); it != input_map.end(); it++)
        {
            std::cout << "{" << it->first << ", " << it->second << "}";

            if(idx++ < (input_map_size - 1))
                std::cout << ", ";
        }

        std::cout << " }" << std::endl;
    };

    print_map("u_map_0", u_map_0);

    auto custom_hash = [](const std::pair<int,int>& p)
    {
        return std::hash<int>()(p.first) ^ (std::hash<int>()(p.second) << 1);
    };  // A custom function is required in this case since no built-in has exists for std::pair<int, int>-like keys.

    std::unordered_map<std::pair<int, int>, std::string, decltype(custom_hash)> u_map_1(0, custom_hash); // Should tell initial size (0) since no constructor with just the hash function exists.

    u_map_1.insert({{1, 2}, "A"});
    u_map_1.insert({{3, 4}, "B"});
    u_map_1.insert({{5, 6}, "C"});

    // Unordered multiset: same as multiset, but faster access with unordered elements.
    std::unordered_multiset<int> u_ms_0 = {2, 2, 6, 4, 3, 4, 1, 4, 7, 9};
    print_set("u_ms_0", u_ms_0);

    // Unordered_multimap: same as multimap, but faster access with unordered elements.
    std::unordered_multimap<int, std::string> u_mm_0 =
    {
        {1, "Monday"    },
        {2, "Tuesday"   },
        {1, "Montag"    },
        {3, "Wednesday" },
        {3, "Mittwoch"  },
        {2, "Dienstag"  },
        {4, "Donnerstag"},
        {5, "Freitag"   },
        {6, "Samstag"   },
        {7, "Sonntag"   },
    };
    
    auto print_multimap = [](const std::string& multimap_name, const auto& input_multimap) -> void
    {
        using MapType   = std::decay_t<decltype(input_multimap)>;
        using KeyType   = typename MapType::key_type;
        using ValueType = typename MapType::mapped_type;

        std::set<KeyType> multimap_keys;
        for (auto it = input_multimap.begin(); it != input_multimap.end(); ++it)
            multimap_keys.insert(it->first);

        std::cout << multimap_name << " = " << std::endl << "{ " << std::endl;

        std::vector<ValueType> key_values;

        for (auto key : multimap_keys)
        {
            auto key_range = input_multimap.equal_range(key);
            key_values.clear();

            for (auto it = key_range.first; it != key_range.second; ++it)
                key_values.emplace_back(it->second);

            std::ostringstream oss;
            oss << key; // requires operator<< for KeyType
            printSequenceContainer(oss.str(), key_values);
        }

        std::cout << " }" << std::endl;
    };

    print_multimap("u_mm_0", u_mm_0);
}

int main()
{
    TestSequenceContainers();
    TestContainerAdaptors();
    TestAssociativeContainers();
    TestUnorderedContainers();

    return 0;
}

/**************************************/
